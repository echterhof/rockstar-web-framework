# Internationalization (i18n)

## Overview

The Rockstar Web Framework provides comprehensive internationalization (i18n) support, enabling you to build applications that serve users in multiple languages. The i18n system supports translation management, pluralization, parameter substitution, language detection, and fallback mechanisms.

**When to use i18n:**
- Building applications for international audiences
- Supporting multiple languages in your application
- Providing localized error messages and user interfaces
- Creating region-specific content

**Key benefits:**
- **YAML-Based Translations**: Easy-to-manage locale files in YAML format
- **Pluralization Support**: Handle singular/plural forms correctly per language
- **Parameter Substitution**: Dynamic content in translations
- **Language Detection**: Automatic language detection from headers
- **Fallback Mechanism**: Graceful degradation to default language
- **Nested Keys**: Organize translations hierarchically

## Quick Start

Here's a minimal example of using i18n:

```go
package main

import (
    "log"
    "time"
    "github.com/echterhof/rockstar-web-framework/pkg"
)

func main() {
    // Configure i18n
    config := pkg.FrameworkConfig{
        ServerConfig: pkg.ServerConfig{
            ReadTimeout:  10 * time.Second,
            WriteTimeout: 10 * time.Second,
            EnableHTTP1:  true,
        },
        I18nConfig: pkg.I18nConfig{
            DefaultLocale:     "en",
            LocalesDir:        "./locales",
            SupportedLocales:  []string{"en", "de", "fr"},
            FallbackToDefault: true,
        },
    }

    app, err := pkg.New(config)
    if err != nil {
        log.Fatal(err)
    }

    router := app.Router()

    // Use translations in handlers
    router.GET("/welcome", func(ctx pkg.Context) error {
        i18n := ctx.I18n()
        
        // Translate a message
        message := i18n.Translate("message.welcome")
        
        return ctx.JSON(200, map[string]interface{}{
            "message": message,
            "locale": i18n.GetLanguage(),
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

## Configuration

### Framework Configuration

Configure i18n in your framework setup:

```go
config := pkg.FrameworkConfig{
    I18nConfig: pkg.I18nConfig{
        // Default language when translation not found
        DefaultLocale: "en",
        
        // Directory containing locale files
        LocalesDir: "./locales",
        
        // List of supported languages
        SupportedLocales: []string{"en", "de", "fr", "es"},
        
        // Fall back to default locale if translation missing
        FallbackToDefault: true,
    },
}
```

### Locale File Format

Create locale files in YAML format with nested structure:

**File: `locales/locales.en.yaml`**
```yaml
# English translations
message:
  welcome: "Welcome to our application"
  goodbye: "Thank you for visiting"
  
error:
  authentication:
    failed: "Authentication failed"
    invalid_token: "Invalid authentication token"
    token_expired: "Your session has expired"
  
  validation:
    missing_field: "Required field '{{field}}' is missing"
    invalid_format: "Invalid format for field '{{field}}'"
  
  request:
    rate_limit_exceeded: "Rate limit exceeded: {{limit}} requests per {{window}}"

log:
  server:
    starting: "Server starting on {{address}}"
    started: "Server started successfully"
  
  request:
    completed: "Request completed: {{method}} {{path}} - {{status}} ({{duration}}ms)"

# Pluralization support
item:
  count:
    one: "{{count}} item"
    other: "{{count}} items"
```

**File: `locales/locales.de.yaml`**
```yaml
# German translations
message:
  welcome: "Willkommen in unserer Anwendung"
  goodbye: "Vielen Dank für Ihren Besuch"
  
error:
  authentication:
    failed: "Authentifizierung fehlgeschlagen"
    invalid_token: "Ungültiges Authentifizierungstoken"
    token_expired: "Ihre Sitzung ist abgelaufen"
  
  validation:
    missing_field: "Erforderliches Feld '{{field}}' fehlt"
    invalid_format: "Ungültiges Format für Feld '{{field}}'"
  
  request:
    rate_limit_exceeded: "Ratenlimit überschritten: {{limit}} Anfragen pro {{window}}"

log:
  server:
    starting: "Server startet auf {{address}}"
    started: "Server erfolgreich gestartet"
  
  request:
    completed: "Anfrage abgeschlossen: {{method}} {{path}} - {{status}} ({{duration}}ms)"

# Pluralization support
item:
  count:
    one: "{{count}} Artikel"
    other: "{{count}} Artikel"
```

### File Naming Convention

Locale files must follow this naming pattern:
- `locales.{locale}.yaml` or `locales.{locale}.yml`
- Examples: `locales.en.yaml`, `locales.de.yaml`, `locales.fr.yaml`

## Usage

### Basic Translation

Translate keys using the i18n manager:

```go
router.GET("/api/message", func(ctx pkg.Context) error {
    i18n := ctx.I18n()
    
    // Simple translation
    message := i18n.Translate("message.welcome")
    
    return ctx.JSON(200, map[string]interface{}{
        "message": message,
    })
})
```

### Translation with Parameters

Use parameter substitution for dynamic content:

```go
router.GET("/api/error/:field", func(ctx pkg.Context) error {
    field := ctx.Params()["field"]
    i18n := ctx.I18n()
    
    // Translation with parameters
    message := i18n.Translate("error.validation.missing_field", map[string]interface{}{
        "field": field,
    })
    
    return ctx.JSON(400, map[string]interface{}{
        "error": message,
    })
})
```

### Multiple Parameters

Pass multiple parameters to translations:

```go
router.GET("/api/rate-limit", func(ctx pkg.Context) error {
    i18n := ctx.I18n()
    
    message := i18n.Translate("error.request.rate_limit_exceeded", map[string]interface{}{
        "limit": 100,
        "window": "minute",
    })
    
    return ctx.JSON(429, map[string]interface{}{
        "error": message,
    })
})
```

### Pluralization

Handle singular and plural forms correctly:

```go
router.GET("/api/items/:count", func(ctx pkg.Context) error {
    count, _ := strconv.Atoi(ctx.Params()["count"])
    i18n := ctx.I18n()
    
    // Pluralization - automatically selects correct form
    message := i18n.TranslatePlural("item.count", count, map[string]interface{}{
        "count": count,
    })
    
    return ctx.JSON(200, map[string]interface{}{
        "message": message,
    })
})
```

Pluralization rules:
- English/German: `.one` for count == 1, `.other` for everything else
- Define plural forms in locale files:
  ```yaml
  item:
    count:
      one: "{{count}} item"
      other: "{{count}} items"
  ```

### Setting Language

Change the current language dynamically:

```go
router.POST("/api/locale/:locale", func(ctx pkg.Context) error {
    locale := ctx.Params()["locale"]
    i18n := ctx.I18n()
    
    // Set language
    if err := i18n.SetLanguage(locale); err != nil {
        return ctx.JSON(400, map[string]interface{}{
            "error": "Unsupported locale",
        })
    }
    
    message := i18n.Translate("message.success.updated")
    
    return ctx.JSON(200, map[string]interface{}{
        "message": message,
        "locale": locale,
    })
})
```

### Getting Current Language

Retrieve the active language:

```go
router.GET("/api/locale", func(ctx pkg.Context) error {
    i18n := ctx.I18n()
    
    return ctx.JSON(200, map[string]interface{}{
        "current_locale": i18n.GetLanguage(),
        "default_locale": i18n.GetDefaultLanguage(),
        "supported_locales": i18n.GetSupportedLanguages(),
    })
})
```

### Translating with Specific Language

Translate to a specific language without changing the current locale:

```go
router.GET("/api/translate/:locale/:key", func(ctx pkg.Context) error {
    locale := ctx.Params()["locale"]
    key := ctx.Params()["key"]
    i18n := ctx.I18n()
    
    // Translate with specific language
    message := i18n.TranslateWithLang(locale, key)
    
    return ctx.JSON(200, map[string]interface{}{
        "locale": locale,
        "key": key,
        "translation": message,
    })
})
```

## Language Detection and Fallback

### Accept-Language Header Detection

Detect language from HTTP Accept-Language header:

```go
router.GET("/api/auto-locale", func(ctx pkg.Context) error {
    // Get Accept-Language header
    acceptLang := ctx.GetHeader("Accept-Language")
    i18n := ctx.I18n()
    
    // Parse language (simple example - use proper parser in production)
    detectedLocale := "en" // default
    if len(acceptLang) >= 2 {
        lang := acceptLang[:2]
        
        // Check if supported
        if i18n.IsLanguageSupported(lang) {
            detectedLocale = lang
            i18n.SetLanguage(detectedLocale)
        }
    }
    
    message := i18n.Translate("message.welcome")
    
    return ctx.JSON(200, map[string]interface{}{
        "detected_locale": detectedLocale,
        "message": message,
    })
})
```

### Fallback Behavior

When a translation is not found:

1. **Primary Lookup**: Check requested locale
2. **Fallback**: If `FallbackToDefault` is true, check default locale
3. **Key Return**: If still not found, return the key itself

```go
// Example: Translation not found
i18n.SetLanguage("fr") // French
message := i18n.Translate("some.missing.key")
// Returns: "some.missing.key" (key itself)

// With fallback enabled
config.I18nConfig.FallbackToDefault = true
// If key exists in default locale (en), returns English translation
// Otherwise, returns the key
```

### Custom Fallback Logic

Implement custom fallback logic:

```go
func TranslateWithFallback(i18n pkg.I18nManager, key string, locales []string) string {
    // Try each locale in order
    for _, locale := range locales {
        translation := i18n.TranslateWithLang(locale, key)
        if translation != key {
            return translation
        }
    }
    
    // Return key if not found in any locale
    return key
}

// Usage
message := TranslateWithFallback(i18n, "message.welcome", []string{"fr", "de", "en"})
```

## Integration

### i18n with Error Handling

Translate framework errors:

```go
router.GET("/api/protected", func(ctx pkg.Context) error {
    // Create framework error with i18n key
    err := &pkg.FrameworkError{
        Code: pkg.ErrCodeAuthenticationFailed,
        Message: "Authentication failed",
        StatusCode: 401,
        I18nKey: "error.authentication.failed",
    }
    
    // Translate error
    i18n := ctx.I18n()
    translatedMessage := i18n.TranslateError(err)
    
    return ctx.JSON(401, map[string]interface{}{
        "error": translatedMessage,
    })
})
```

### i18n with Logging

Use i18n in log messages:

```go
router.GET("/api/data", func(ctx pkg.Context) error {
    i18n := ctx.I18n()
    
    // Log with translation
    logMessage := i18n.Translate("log.request.received", map[string]interface{}{
        "method": ctx.Request().Method,
        "path": ctx.Request().URL.Path,
    })
    
    ctx.Logger().Info(logMessage)
    
    // ... handle request
    
    return ctx.JSON(200, data)
})
```

### i18n with Validation

Provide localized validation messages:

```go
func ValidateUser(user *User, i18n pkg.I18nManager) []string {
    var errors []string
    
    if user.Email == "" {
        errors = append(errors, i18n.Translate("error.validation.missing_field", 
            map[string]interface{}{"field": "email"}))
    }
    
    if user.Name == "" {
        errors = append(errors, i18n.Translate("error.validation.missing_field",
            map[string]interface{}{"field": "name"}))
    }
    
    return errors
}

router.POST("/api/users", func(ctx pkg.Context) error {
    var user User
    if err := ctx.BindJSON(&user); err != nil {
        return ctx.JSON(400, map[string]interface{}{
            "error": "Invalid request",
        })
    }
    
    i18n := ctx.I18n()
    if errors := ValidateUser(&user, i18n); len(errors) > 0 {
        return ctx.JSON(400, map[string]interface{}{
            "errors": errors,
        })
    }
    
    // ... create user
    
    return ctx.JSON(201, user)
})
```

### i18n Middleware

Create middleware for automatic language detection:

```go
func LanguageDetectionMiddleware(ctx pkg.Context, next pkg.HandlerFunc) error {
    i18n := ctx.I18n()
    
    // Priority 1: Query parameter
    if locale := ctx.Query()["locale"]; locale != "" {
        if i18n.IsLanguageSupported(locale) {
            i18n.SetLanguage(locale)
        }
    } else if locale := ctx.Query()["lang"]; locale != "" {
        if i18n.IsLanguageSupported(locale) {
            i18n.SetLanguage(locale)
        }
    }
    
    // Priority 2: Cookie
    if locale, err := ctx.Cookie("locale"); err == nil && locale != "" {
        if i18n.IsLanguageSupported(locale) {
            i18n.SetLanguage(locale)
        }
    }
    
    // Priority 3: Accept-Language header
    if acceptLang := ctx.GetHeader("Accept-Language"); acceptLang != "" {
        // Parse and set language (simplified)
        if len(acceptLang) >= 2 {
            lang := acceptLang[:2]
            if i18n.IsLanguageSupported(lang) {
                i18n.SetLanguage(lang)
            }
        }
    }
    
    return next(ctx)
}

// Apply middleware
router.Use(LanguageDetectionMiddleware)
```

## Best Practices

### Organize Translations Hierarchically

Use nested keys for better organization:

```yaml
# Good: Organized by category
error:
  authentication:
    failed: "Authentication failed"
    invalid_token: "Invalid token"
  validation:
    missing_field: "Field '{{field}}' is missing"
    invalid_format: "Invalid format for '{{field}}'"

# Avoid: Flat structure
error_authentication_failed: "Authentication failed"
error_authentication_invalid_token: "Invalid token"
error_validation_missing_field: "Field '{{field}}' is missing"
```

### Use Consistent Key Naming

Follow a consistent naming convention:

```yaml
# Good: Consistent pattern
message.welcome
message.goodbye
error.authentication.failed
error.validation.missing_field
log.server.starting
log.request.completed

# Avoid: Inconsistent naming
welcomeMessage
error_auth_failed
serverStartingLog
```

### Provide Context in Parameters

Use descriptive parameter names:

```yaml
# Good: Clear parameter names
"User {{username}} logged in from {{ip_address}}"
"File {{filename}} uploaded successfully ({{file_size}} bytes)"

# Avoid: Generic parameter names
"User {{param1}} logged in from {{param2}}"
"File {{p1}} uploaded successfully ({{p2}} bytes)"
```

### Handle Missing Translations Gracefully

Always provide fallback translations:

```go
func SafeTranslate(i18n pkg.I18nManager, key string, defaultMsg string) string {
    translation := i18n.Translate(key)
    
    // If translation equals key, it wasn't found
    if translation == key {
        return defaultMsg
    }
    
    return translation
}
```

### Keep Translations in Sync

Use a checklist to ensure all locales have the same keys:

```bash
# Script to check translation coverage
#!/bin/bash
for locale in en de fr es; do
    echo "Checking locales.$locale.yaml"
    # Extract keys and compare
done
```

### Test Translations

Write tests for translation coverage:

```go
func TestTranslationCoverage(t *testing.T) {
    i18n, _ := pkg.NewI18nManager(pkg.I18nConfig{
        DefaultLocale: "en",
        LocalesDir: "./locales",
        SupportedLocales: []string{"en", "de"},
    })
    
    requiredKeys := []string{
        "message.welcome",
        "error.authentication.failed",
        "error.validation.missing_field",
    }
    
    for _, locale := range []string{"en", "de"} {
        i18n.SetLanguage(locale)
        for _, key := range requiredKeys {
            translation := i18n.Translate(key)
            if translation == key {
                t.Errorf("Missing translation for %s in locale %s", key, locale)
            }
        }
    }
}
```

### Managing Translations

1. **Version Control**: Keep locale files in version control
2. **Translation Service**: Consider using translation management services
3. **Professional Translation**: Use professional translators for production
4. **Regular Updates**: Keep translations updated with new features
5. **Community Contributions**: Allow community to contribute translations

## API Reference

See [I18n API](../api/i18n.md) for complete i18n API documentation.

## Examples

See the `examples/i18n_example.go` file in the repository for a complete working implementation.

## Troubleshooting

### Translation Not Found

**Problem**: Translations return the key instead of translated text

**Solutions**:
- Verify locale file exists in LocalesDir
- Check file naming: `locales.{locale}.yaml`
- Ensure key exists in locale file
- Verify YAML syntax is correct
- Check if locale is loaded: `i18n.GetSupportedLanguages()`

### Pluralization Not Working

**Problem**: Plural forms not displaying correctly

**Solutions**:
- Use `TranslatePlural()` instead of `Translate()`
- Define both `.one` and `.other` forms in locale file
- Pass count parameter in params map
- Verify plural rule is registered for locale

### Parameters Not Substituted

**Problem**: Placeholders like `{{field}}` appear in output

**Solutions**:
- Pass parameters as map: `map[string]interface{}{"field": "email"}`
- Use correct placeholder syntax: `{{param}}` not `{param}` or `$param`
- Verify parameter names match between translation and code

### Locale Files Not Loading

**Problem**: Translations not available after startup

**Solutions**:
- Verify LocalesDir path is correct
- Check file permissions
- Ensure files match naming pattern: `locales.*.yaml`
- Check application logs for loading errors
- Verify YAML syntax with a validator

## Related Documentation

- [Configuration Guide](configuration.md) - Configuring i18n
- [Context API](../api/context.md) - Accessing i18n from context
- [I18n API Reference](../api/i18n.md) - Complete I18n API
